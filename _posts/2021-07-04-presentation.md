---
title: "한 주의 마무리, 알고리즘 문제 정리"
date: 2021-07-04
permalink: /posts/2021/07/blog-post-0/
tags:
  - cplusplus
  - string
---

이번주부터 실전문제를 풀기 시작했다.
오랜만에 풀어서인지, 아니면 문제가 어려워서인지는 모르겠지만, 많이 틀렸다. ~~아마 전자일 확률이 높다~~
매주마다 포스트를 하며 틀렸던 문제들에 대하여 되짚고 가고자 한다. 이번주는 그리디 유형의 문제에 대하여 풀이하였다.

## 1. 곱하기 혹은 더하기

02984 처럼 하나의 문자열이 들어오면, 하나씩 숫자를 확인하여 이 숫자들로 곱하기와 더하기를 해서 만들 수 있는 가장 큰 수:576을 출력하면 된다.

```
#include <bits/stdc++.h>

using namespace std;
int main(){
    string s;
    cin>>s;
    int result = s[0]-'0';

    // 틀린 부분
    // int i=0;
    // int n=1;
    // while(1){
    //     scanf("%1d",&arr[i]);    =>    scanf("%c",&arr[i])
    //     if(!isdigit(arr[i])){    =>
    //         n=i;
    //         break;
    //     }
    //     i++;
    // }

    for(int i=1;i<s.length();i++){
        int k = s[i]-'0';
        if(k==0||k==1||result==0){
            result+=k;
        }
        else{
            result*=k;
        }
    }
    printf("%d",result);
    return 0;
}
```

우선 첫번째로 3주만에 풀다보니 감이 많이 떨어졌어서 그런지 **char -'0'**을 생각하지 못했다.
두번째로 string으로 처리할 생각도 하지 못하고 scanf로 형식을 지정하여 input을 받으려고 했다. 그리고 그러다보니 문자열 끝을 정해주기 위해서 앞에서부터 하나씩 읽다가 개행문자가 나오면 digit이 아니므로 그 순간 break를 걸어 빠져나오려고 했는데 이 과정에서 안일했다. isdigit은 parameter가 int긴 하지만 ascii code '0'~'9'를 받아 처리한다. 그런데 나는 실제 int를 넣어주고 있었다.

## 2. 무지의 먹방 라이브

풀긴 풀었는데 효율성 0점이었다.

무지는 1초에 1 음식만 먹을 수 있고, 회전초밥집에 있어서 1초마다 돌아가면서 먹는다.<br>
즉 배열 [3,1,2]가 있으면 0~1초에 3에서 1을 먹어 [2,1,2]가 되고 그 다음 자리로 넘어간다.<br>
네트워크 지연이 1초간 있을 때 지연이 복구되고 나서 먹을 음식의 index를 뿌려주면 된다. (ex t=5, then 첫번째 음식부터 다시 먹으면 된다.)

다음은 나의 효율 0점 코드이다.

```
 int solution(vector<int> food_times, long long k) {
     int i;
     int answer;
     int result = 0;
     for(int i=0;i<food_times.size();i++){
         result+=food_times[i];
     }
     if(result<=k) return -1;
     while(1){

         for(i=0;i<food_times.size();i++){
             if(food_times[i]==0){
                 continue;
             }
             food_times[i]--;
             k--;
             if(k<0){
             answer = i%food_times.size()+1;
             return answer;
         }
         }

     }
    return 0;
 }
```

이중포문 사용하니까 효율성 0점이었다. 인풋 데이터 생각했을 때 충분히 그럴만하다.
이럴 때는 자료구조를 사용하면 좋다. 처음 아이디어를 떠올릴 때 우선순위 큐를 생각하긴 했었는데 구현에 있어서 자신감이 없었다. 앞으로 공부하면 차차 나아질 것이라 생각한다. ~~(사실 최근 좀 해이해진 거 같아서 나 스스로의 도전이라 생각하고 파이썬으로 언어를 바꿔서 코딩중에 있다.)~~

정답코드는 파이썬으로 다시 풀어볼 것이므로 업로드하지 않겠다.

## 3. 만들 수 없는 돈

입력 받을 동전의 개수와 동전의 값이 주어졌을 때 이 동전들의 조합으로 만들 수 없는 최솟값을 출력한다.
다음은 나의 틀린 코드이다.

```
int n;
int arr[1000];
int bumwee[1000000000];

// 막힌 중복순열 구현
void cmm(int a){
    if(a==n){
        return;
    }


}
int main(){

    scanf("%d",&n);

    int result=2;
    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
        result+=arr[i];
    }
    sort(arr,arr+n);
    cmm(0);
    for(int i=1;i<=result;i++){
        if(bumwee[i]==0){
            printf("%d",i);
            return 0;
        }
    }


}
```

우선 동전의 합을 구해서 탐색 범위를 좁혀준 것은 좋았다. 그러나 구현에서 어려움을 느꼈던 것은, 이것을 중복 순열(각 동전의 차례마다 이번 arr[index]에서 값을 더해줄 것인가 말 것인가)로 풀려고 했는데, 이 과정에서 어려움을 겪었다. 재귀함수로 구현하고, 그리고 그 함수에서 각기 다른 조건으로 두번 불러주면 될 거 같은데 거기서 무엇을 return 할 것인가에서 막혔다. _근데 같은 것이 있다보니 생각해보면 중복순열은 아니고 모든 부분집합 구하는 문제다_ <br>
사실 문제풀이의 아이디어는 중복순열과는 상관이 없이 cycle의 개념이었지만, 스스로 (중복)순열/조합, 부분집합 구하기의 아쉬움을 느껴 이번 포스트에 추가했다.

### Tasks

이번 그리디 문제를 풀고 나의 부족한 점을 스스로 알게 되었다. 일단 python으로 공부를 다시 처음부터 하고 있긴 하지만, 이번 주 내로 한 번 조합,순열,중복조합,중복순열 등에 대하여 library를 이용한 것과 기본적인 python 내장 함수를 통한 구현하는 과정을 포스트로 정리해서 올릴 것이다. 또한 부분집합 유형도 한번 정리해서 올리겠다.
